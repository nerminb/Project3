set.seed(1)
energyIndex <- createDataPartition(energyData$heating_load, p = 0.7, list = FALSE)
energyTrain <- energyData[energyIndex, ]
energyTest <- energyData[-energyIndex, ]
# Define training control
trctrl <- trainControl(method = "cv", number = 10)
# Linear Regression Model
lmFit <- train(heating_load ~ .,
data = select(energyTrain, -c(compactness_level)),
method = "lm",
preProcess = c("center", "scale"),
trControl = trctrl)
lmFit
# Boosted Tree Model
set.seed(5)
boostFit <- train(heating_load ~.,
select(energyTrain, -c(compactness_level)),
method = "gbm",
trControl = trctrl,
preProcess = c("center", "scale"),
verbose = FALSE)
boostFit
# Random Forest Model
set.seed(5)
# Fit the random forest model on training set
rfFit <- train(heating_load ~ .,
data = select(energyTrain, -c(compactness_level)),
method = "rf",
preProcess = c("center", "scale"),
trControl = trctrl)
rfFit
# predict on test set
predfitLm <- predict(lmFit, newdata = energyTest)
predfitBoost <- predict(boostFit, newdata = energyTest)
predfitRF <- predict(rfFit, newdata = energyTest)
library(tidyverse)
library(dplyr)
library(ggplot2)
library(caret)
library(DT)
energyData <- read_csv("energy_efficiency.csv")
energyData <- select(energyData, -cooling_load)
# Convert categorical variables to factors
cols <- c("orientation", "glazing_area_dist")
energyData[cols] <- lapply(energyData[cols], factor)
# Create new variable for compactness level
energyData$compactness_level <- cut(energyData$relative_compactness, c(0.6, 0.68, 0.76, 0.84, 0.92, 1))
levels(energyData$compactness_level) = c("Very Low", "Low", "Medium", "High", 'Very High')
# options: p = 0.7, select which variables to use, number of CV folds,
set.seed(1)
energyIndex <- createDataPartition(energyData$heating_load, p = 0.7, list = FALSE)
energyTrain <- energyData[energyIndex, ]
energyTest <- energyData[-energyIndex, ]
# Define training control
trctrl <- trainControl(method = "cv", number = 10)
# Set seed for reproducible
set.seed(5)
# Linear Regression Model
lmFit <- train(heating_load ~ .,
data = select(energyTrain, -c(compactness_level)),
method = "lm",
preProcess = c("center", "scale"),
trControl = trctrl)
lmFit
# Boosted Tree Model
set.seed(5)
boostFit <- train(heating_load ~.,
select(energyTrain, -c(compactness_level)),
method = "gbm",
trControl = trctrl,
preProcess = c("center", "scale"),
verbose = FALSE)
boostFit
# Random Forest Model
set.seed(5)
# Fit the random forest model on training set
rfFit <- train(heating_load ~ .,
data = select(energyTrain, -c(compactness_level)),
method = "rf",
preProcess = c("center", "scale"),
trControl = trctrl)
rfFit
# predict on test set
predfitLm <- predict(lmFit, newdata = energyTest)
predfitBoost <- predict(boostFit, newdata = energyTest)
predfitRF <- predict(rfFit, newdata = energyTest)
predfitLm
# evaluate the model performances by comparing the testing RMSE values
testResults <- rbind(postResample(predfitLm, energyTest$heating_load),
postResample(predfitBoost, energyTest$heating_load),
postResample(predfitRF, energyTest$heating_load))
testResults <- data.frame(testResults)
row.names(testResults) <- c("Linear Regression",
"Boosted Tree",
"Random Forest")
testResults
# Find the best model with lowest RMSE value
bestModel <- rownames(testResults[testResults$RMSE == min(testResults$RMSE), ])
bestModel
help(numericInput)
help(sliderInput)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
help(actionButton)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
help(reactiveValues)
runApp()
runApp()
boostFit
summary(boostFit)
boostFit
boostFit$results
names(boostFit)
boostFit(finalModel)
boostFit$finalModel
runApp()
runApp()
runApp()
testResults
testResults <- data.frame(Model = c("Linear Regression", "Boosted Tree", "Random Forest"),
testResults)
testResults
runApp()
specify_decimal(postResample(predfitLm, energyTest$heating_load), 5)
format(round(postResample(predfitLm, energyTest$heating_load), 4), nsmall = 4)
format(round(postResample(predfitLm, energyTest$heating_load), 2), nsmall = 2)
format(round(postResample(predfitLm, energyTest$heating_load), 2))
format(round(postResample(predfitLm, energyTest$heating_load), 4))
round(postResample(predfitLm, energyTest$heating_load), 4)
testResults
testResults <- rbind(round(postResample(predfitLm, energyTest$heating_load), 4),
round(postResample(predfitBoost, energyTest$heating_load), 4),
round(postResample(predfitRF, energyTest$heating_load), 4))
testResults
testResults <- data.frame(Model = c("Linear Regression", "Boosted Tree", "Random Forest"),
testResults)
testResults
help(tableOutput)
runApp()
help("checkboxGroupInput")
runApp()
runApp()
runApp()
runApp()
as.name("ehgwrf")
class(as.name("dgsrf"))
runApp()
runApp()
runApp()
names(energyTrain)
runApp()
energyTrain
names(energyTrain)[-1]
names(select(energyTrain, -c(compactness_level)))
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
paste("surface_area", "wall_area")
paste(c("surface_area", "wall_area"), "+")
paste(c("surface_area", "wall_area"), collapse = "+")
runApp()
runApp()
predfitLm <- predict(lmFit, newdata = c(0.62, 808.5, 367.5, 220.5, 3.5, 2, 0, 0))
pred_values <- data.frame(
relative_compactness = 0.62,
surface_area = 808.5,
wall_area = 367.5,
roof_area = 220.5,
overall_height = 3.5,
orientation = 2,
glazing_area = 0,
glazing_area_dist = 0
)
pred_values
predfitLm <- predict(lmFit, newdata = pred_values)
cols <- c("orientation", "glazing_area_dist")
pred_values[cols] <- lapply(pred_values[cols], factor)
predfitLm <- predict(lmFit, newdata = pred_values)
pred_values <- data.frame(
relative_compactness = 0.62,
surface_area = 808.5,
wall_area = 367.5,
roof_area = 220.5,
overall_height = 3.5,
orientation = 2,
glazing_area = 0
)
cols <- c("orientation", "glazing_area_dist")
pred_values[cols] <- lapply(pred_values[cols], factor)
predfitLm <- predict(lmFit, newdata = pred_values)
pred_values <- data.frame(
relative_compactness = 0.62,
surface_area = 808.5,
wall_area = 367.5,
roof_area = 220.5,
overall_height = 3.5,
orientation = 2,
glazing_area = 0,
glazing_area_dist = 0
)
cols <- c("orientation", "glazing_area_dist")
pred_values[cols] <- lapply(pred_values[cols], factor)
predfitLm <- predict(lmFit, newdata = pred_values)
predfitLm
pred_values <- data.frame(
relative_compactness = 0.62,
surface_area = 600,
wall_area = 367.5,
roof_area = 220.5,
overall_height = 3.5,
orientation = 2,
glazing_area = 0,
glazing_area_dist = 0
)
cols <- c("orientation", "glazing_area_dist")
pred_values[cols] <- lapply(pred_values[cols], factor)
predfitLm <- predict(lmFit, newdata = pred_values)
predFitLm
predfitLm
pred_values <- data.frame(
relative_compactness = 0.9,
surface_area = 600,
wall_area = 367.5,
roof_area = 220.5,
overall_height = 3.5,
orientation = 2,
glazing_area = 0,
glazing_area_dist = 0
)
cols <- c("orientation", "glazing_area_dist")
pred_values[cols] <- lapply(pred_values[cols], factor)
predfitLm <- predict(lmFit, newdata = pred_values)
predfitLm
pred_values <- data.frame(
relative_compactness = 0.9,
surface_area = 600,
wall_area = 367.5,
roof_area = 220.5,
overall_height = 3.5,
orientation = 2,
glazing_area = 0,
glazing_area_dist = 0
)
cols <- c("orientation", "glazing_area_dist")
pred_values[cols] <- lapply(pred_values[cols], factor)
predfitLm <- predict(boostFit, newdata = pred_values)
predfitLm
# Define server logic required to draw a histogram
shinyServer(function(input, output, session) {
output$energyDataTable <- renderDataTable(
datatable(energyData,
filter = "top"),
server = FALSE
)
output$filtered_row <-
renderPrint({
input[["dt_rows_all"]]
})
output$download_filtered <-
downloadHandler(
filename = "Filtered Data.csv",
content = function(file){
write.csv(energyData[input[["dt_rows_all"]], ],
file)
}
)
output$downloadFull <- downloadHandler('energy_efficiency.csv',
content = function(con) {
write.csv(energyData, con)
}
)
# Data Exploration: Summary Statistics
output$summaryStats <- renderTable({
# Subset by columns we want to analyze
energyStats <- energyData[ , c("relative_compactness",
"surface_area",
"wall_area",
"roof_area",
"heating_load")]
# Function for summary statistics for energy stats
summaryStats <- data.frame(do.call(cbind, lapply(energyStats, summary, digits = 3)))
summaryStats$stat <- rownames(summaryStats)
summaryStats <- summaryStats[ , c("stat", "relative_compactness", "surface_area",
"wall_area", "roof_area", "heating_load")]
colnames(summaryStats) <- c("Stat", "Relative Compactness", "Surface Area",
"Wall Area", "Roof Area", "Heating Load")
summaryStats
})
# Data Exploration: Scatter Plots
output$scatterPlot <- renderPlot({
ggplot(energyData, aes(x = !!input$scatterVariable, y = heating_load)) +
geom_point(stat = "identity") +
geom_smooth(data = energyData, aes(x = !!input$scatterVariable, y = heating_load),
method = "lm") +
labs(x = "Surface Area", y = "Heating Load")
})
# Data Exploration: Box Plots
output$boxPlot <- renderPlot({
subsetEnergyHL <- subset(energyData,
heating_load >= input$HLRange[1] &
heating_load <= input$HLRange[2])
subsetEnergyHL$overall_height <- as.factor(subsetEnergyHL$overall_height)
levels(subsetEnergyHL$overall_height) <- list("Low" = 3.5,
"High" = 7)
# Numerical summaries
g <- ggplot(subsetEnergyHL, aes(x = !!input$boxPlotVariable, y = heating_load))
g + geom_boxplot() +
geom_point(aes(col = !!input$boxPlotVariable), alpha = 1, size = 1, position = "jitter") +
labs(title = "Boxplot for Heating Load by Overall Height or Relative Compactness",
y = "Heating Load")
})
# Modeling
values <- reactiveValues()
observeEvent(input$fit_model,{
set.seed(1)
energyIndex <- createDataPartition(energyData$heating_load, p = input$trainSize, list = FALSE)
energyTrain <- energyData[energyIndex, ]
energyTest <- energyData[-energyIndex, ]
# Define training control
trctrl <- trainControl(method = "cv", number = input$cvFolds)
# Set seed for reproducible
set.seed(5)
modelVars <- paste(input$varsToUse, collapse = "+")
modelFormula <- as.formula(paste('heating_load ~', modelVars))
# Linear Regression Model
lmFit <- train(modelFormula,
data = select(energyTrain, -c(compactness_level)),
method = "lm",
preProcess = c("center", "scale"),
trControl = trctrl)
# Boosted Tree Model
set.seed(5)
boostFit <- train(modelFormula,
data = select(energyTrain, -c(compactness_level)),
method = "gbm",
trControl = trctrl,
preProcess = c("center", "scale"),
verbose = FALSE)
# Random Forest Model
set.seed(5)
# Fit the random forest model on training set
rfFit <- train(modelFormula,
data = select(energyTrain, -c(compactness_level)),
method = "rf",
preProcess = c("center", "scale"),
trControl = trctrl)
# predict on test set
predfitLm <- predict(lmFit, newdata = energyTest)
predfitBoost <- predict(boostFit, newdata = energyTest)
predfitRF <- predict(rfFit, newdata = energyTest)
# evaluate the model performances by comparing the testing RMSE values
testResults <- rbind(postResample(predfitLm, energyTest$heating_load),
postResample(predfitBoost, energyTest$heating_load),
postResample(predfitRF, energyTest$heating_load))
testResults <- data.frame(Model = c("Linear Regression", "Boosted Tree", "Random Forest"),
testResults)
row.names(testResults) <- c("Linear Regression",
"Boosted Tree",
"Random Forest")
# Find the best model with lowest RMSE value
bestModel <- rownames(testResults[testResults$RMSE == min(testResults$RMSE), ])
values$lmFit <- lmFit
values$boostFit <- boostFit
values$rfFit <- rfFit
values$testResults <- testResults
values$bestModel <- bestModel
})
# Output Modeling Results and Comparisons
output$lmFitResults <- renderPrint({
values$lmFit
})
output$boostFitResults <- renderPrint({
values$boostFit
})
output$rfFitResults <- renderPrint({
values$rfFit
})
output$fitStatistics <- renderTable({
values$testResults[] <- lapply(values$testResults, format, decimal.mark = ",", digits = 5)
values$testResults
})
output$finalModel <- renderPrint({
values$bestModel
})
# Output Predictions
observeEvent(input$predict_values,{
pred_values <- data.frame(
relative_compactness = input$relative_compactnessPred,
surface_area = input$surface_areaPred,
wall_area = input$wall_areaPred,
roof_area = input$roof_areaPred,
overall_height = input$overall_heightPred,
orientation = input$orientationPred,
glazing_area = input$glazing_areaPred,
glazing_area_dist = input$glazing_area_distPred
)
predResult <- predict(input$modelPredChoice, newdata = pred_values)
values$predResult <- predResult
})
})
help(sliderInput)
help(numericInput)
runApp()
runApp()
runApp()
runApp()
values
runApp()
runApp()
pred_values <- data.frame(
relative_compactness = 0.9,
surface_area = 600,
wall_area = 367.5,
roof_area = 220.5,
overall_height = 3.5,
orientation = 2,
glazing_area = 0,
glazing_area_dist = 0
)
predfitLm <- predict(lmFit, newdata = pred_values)
pred_values <- data.frame(
relative_compactness = 0.9,
surface_area = 600,
wall_area = 367.5,
roof_area = 220.5,
overall_height = 3.5,
orientation = 2,
glazing_area = 0,
glazing_area_dist = 0
)
predfitLm <- predict(lmFit, newdata = pred_values)
pred_values <- data.frame(
relative_compactness = 0.9,
surface_area = 600,
wall_area = 367.5,
roof_area = 220.5,
overall_height = 3.5,
orientation = 2,
glazing_area = 0,
glazing_area_dist = 0
)
cols <- c("orientation", "glazing_area_dist")
pred_values[cols] <- lapply(pred_values[cols], factor)
predfitLm <- predict(boostFit, newdata = pred_values)
predfitLm
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
as.number("egrf")
as.number("0")
as.numeric("0")
runApp()
runApp()
help(textOutput)
help(verbatimTextOutput)
runApp()
runApp()
runApp()
help(a)
runApp()
runApp()
runApp()
install.packages(shinythemes)
install.packages("shinythemes")
runApp()
runApp()
runApp()
runApp()
runApp()
intall.packages("DT", "caret")
packages.install("DT", "caret")
library(shiny)
library(tidyverse)
library(dplyr)
library(ggplot2)
library(caret)
library(DT)
shiny::runGitHub("Project3", "nerminb", ref="main")
library(shiny)
library(tidyverse)
library(dplyr)
library(ggplot2)
library(caret)
library(DT)
shiny::runGitHub("Project3", "nerminb", ref="main")
runApp()
